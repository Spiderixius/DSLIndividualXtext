/*
 * generated by Xtext 2.12.0
 */
package com.metagamedsl.validation

import com.metagamedsl.metaGameLanguage.ObjectDeclaration
import com.metagamedsl.metaGameLanguage.Game
import com.metagamedsl.metaGameLanguage.GridSize
import com.metagamedsl.metaGameLanguage.MetaGameLanguagePackage
import org.eclipse.xtext.validation.Check
import com.metagamedsl.metaGameLanguage.Property
import java.util.HashMap
import com.metagamedsl.metaGameLanguage.Object
import com.metagamedsl.metaGameLanguage.Declaration
import com.metagamedsl.services.MetaGameLanguageGrammarAccess.ObjectDeclarationElements

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MetaGameLanguageValidator extends AbstractMetaGameLanguageValidator {

	public static val INVALID_NAME = "invalidName"
	public static val DUPLICATE_NAME = "duplicateName"

	/**
	 * The method checks whether the name of the game starts with a capital letter.
	 * @param Game Allows access to the representation of the Game object.
	 */
	@Check
	def void checkNameStartsWithCapital(Game game) {
		if (!Character.isUpperCase(game.name.charAt(0))) {
			warning("Name should start with a capital.", MetaGameLanguagePackage.Literals.GAME__NAME, INVALID_NAME)
		}
	}

	/**
	 * The method checks whether the x and y grid constraints are being violated.
	 * @param GridSize Allows access to the representation of the Grid Size object.
	 */
	@Check
	def void checkGridCoordinates(GridSize grid) {
		// Variables
		var minValue = 1
		var maxValue = 10
		var x = grid.size.x
		var y = grid.size.y
		var gridSize = MetaGameLanguagePackage.Literals.GRID_SIZE__SIZE

		if (x < minValue || y < minValue) {
			error("Grid size must be at least 1.", gridSize)
		} else if (x > maxValue || y > maxValue) {
			error("Grid size must be 10 or under.", gridSize)
		}
	}

	/**
	 * Validate the positions of objects and locations compared to the currently set grid size.
	 * @param
	 */
	@Check
	def void checkCoordinatesComparedToGrid(GridSize grid, ObjectDeclaration obj) {
		var obj_x = obj.coordinates.x
		var obj_y = obj.coordinates.x
		var grid_x = grid.size.x
		var grid_y = grid.size.y

		var obj_coordinates = MetaGameLanguagePackage.Literals.OBJECT__DECLARATIONS

		if (obj_x < grid_x || obj_y > grid_y) {
			error("Coordinates most not exceed grid coordinates.", obj_coordinates)
		}
	}

	/**
	 * Everyone like to be unique, therefore objects and locations should have unique names.
	 * Furthermore attributes within each object/location should also be unique
	 */
	@Check
	def void checkFieldsAreUniqueName(Game game) {
		var map = new HashMap<String, Property>
		var literal = MetaGameLanguagePackage.Literals.PROPERTY__NAME

		for (Property p : game.fields) {
			if (map.containsKey(p.name)) {
				error("Field name " + p.name + " must be unique.", p, literal, DUPLICATE_NAME)
				error("Field name " + p.name + " must be unique.", map.get(p.name), literal, DUPLICATE_NAME)
			} else {
				map.put(p.name, p)
			}
		}
	}

	@Check
	def void checkObjectsAreUniqueName(Object object) {
		var map = new HashMap<String, ObjectDeclaration>
		var literal = MetaGameLanguagePackage.Literals.OBJECT__DECLARATIONS
		var literal2 = MetaGameLanguagePackage.Literals.OBJECT_DECLARATION__NAME
		
		for (ObjectDeclaration objectDeclaration : object.declarations) {
			if (map.containsKey(objectDeclaration.name)) {
				error("Field name " + objectDeclaration.name + " must be unique.", objectDeclaration, literal2, DUPLICATE_NAME)
				error("Field name " + objectDeclaration.name + " must be unique.", map.get(objectDeclaration.name), literal2, DUPLICATE_NAME)
			} else {
				map.put(objectDeclaration.name, objectDeclaration)
			}
		}
	}

	@Check
	def void checkForwardReferences(Game game) {
		// Get a list of properties
		// Check that properties don't reference other properties that are declared later (Forward reference)
	}
}
